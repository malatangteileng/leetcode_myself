给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。  

示例:

输入: [2,1,5,6,2,3]  
输出: 10

**单调栈**入门  
```
单调栈分为单调递增栈和单调递减栈
11. 单调递增栈即栈内元素保持单调递增的栈
12. 同理单调递减栈即栈内元素保持单调递减的栈

操作规则（下面都以单调递增栈为例）
21. 如果新的元素比栈顶元素大，就入栈
22. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小

加入这样一个规则之后，会有什么效果
31. 栈内的元素是递增的
32. 当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素

举个例子，配合下图，现在索引在 6 ，栈里是 1 5 6 。
接下来新元素是 2 ，那么 6 需要出栈。
当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。

当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素
当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。
```
```
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        heights = [0] + heights + [0]
        res = 0
        for i in range(len(heights)):
            #print(stack)
            while stack and heights[stack[-1]] > heights[i]: # 注意单调栈一定要在循环的时候判断栈是否不空
                tmp = stack.pop()                            #弹出的pop是stack中比heights[stack[-1]]大的所有值中最小的那一个
                res = max(res, (i - stack[-1] - 1) * heights[tmp])
            stack.append(i)                                  #这里注意append(i)要在while循环之后，其次这里的i对应小矩形的坐标
        return res
```
本题可以理解为**以第i根柱子为最矮柱子所能延伸的最大面积**  
单调栈两个注意点：  
1.判断栈不空
2.在原始数组的前后加[0]

```
在首尾加了两个0，这个设计真的很精妙啊，我开始用栈这个方法去解决问题的时候，就在考虑如果遍历之后，栈不为空，
那么还需要一步：即弹出栈中所有元素，分别计算最大面积。然而当加了两个0以后，在结束后，栈一定为空！
真的好厉害，若不是调试下，我真的想不到可以这么去解决问题 多谢楼主

问题1：为什么加了两个0以后结束后栈一定为空啊？
因为0入栈的时候，会把前面所有的数全部弹出，如果0最后一个入栈，所有的数都会弹出
问题2：为什么头部还要加一个0啊
头部加0便于处理当栈里只有一个有效元素要弹出的时候计算面积。如果头部不加0，最后一个有效元素被弹出的时候，栈已经为空了，则还需要特殊处理。
```

